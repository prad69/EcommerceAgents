from datetime import datetime, timedelta\nfrom typing import Optional, Dict, Any\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom sqlalchemy.orm import Session\nfrom fastapi import HTTPException, status\nimport uuid\n\nfrom src.core.config import settings\nfrom src.core.database import get_db\nfrom src.models.user import User, UserSession\nfrom src.schemas.user import UserCreate, UserLogin, Token\n\n\nclass AuthService:\n    \"\"\"\n    Authentication and authorization service\n    \"\"\"\n    \n    def __init__(self):\n        self.pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n        self.secret_key = settings.jwt_secret_key\n        self.algorithm = settings.jwt_algorithm\n        self.access_token_expire_minutes = settings.jwt_access_token_expire_minutes\n    \n    def hash_password(self, password: str) -> str:\n        \"\"\"\n        Hash a password using bcrypt\n        \"\"\"\n        return self.pwd_context.hash(password)\n    \n    def verify_password(self, plain_password: str, hashed_password: str) -> bool:\n        \"\"\"\n        Verify a password against its hash\n        \"\"\"\n        return self.pwd_context.verify(plain_password, hashed_password)\n    \n    def create_access_token(\n        self,\n        data: Dict[str, Any],\n        expires_delta: Optional[timedelta] = None\n    ) -> str:\n        \"\"\"\n        Create a JWT access token\n        \"\"\"\n        to_encode = data.copy()\n        \n        if expires_delta:\n            expire = datetime.utcnow() + expires_delta\n        else:\n            expire = datetime.utcnow() + timedelta(minutes=self.access_token_expire_minutes)\n        \n        to_encode.update({\"exp\": expire})\n        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)\n        \n        return encoded_jwt\n    \n    def verify_token(self, token: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Verify and decode a JWT token\n        \"\"\"\n        try:\n            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])\n            return payload\n        except JWTError:\n            return None\n    \n    async def register_user(\n        self,\n        user_data: UserCreate,\n        db: Session\n    ) -> User:\n        \"\"\"\n        Register a new user\n        \"\"\"\n        # Check if user already exists\n        existing_user = db.query(User).filter(\n            (User.email == user_data.email) | (User.username == user_data.username)\n        ).first()\n        \n        if existing_user:\n            if existing_user.email == user_data.email:\n                raise HTTPException(\n                    status_code=status.HTTP_400_BAD_REQUEST,\n                    detail=\"Email already registered\"\n                )\n            else:\n                raise HTTPException(\n                    status_code=status.HTTP_400_BAD_REQUEST,\n                    detail=\"Username already taken\"\n                )\n        \n        # Create new user\n        hashed_password = self.hash_password(user_data.password)\n        \n        new_user = User(\n            email=user_data.email,\n            username=user_data.username,\n            hashed_password=hashed_password,\n            full_name=user_data.full_name,\n            preferences=user_data.preferences or {}\n        )\n        \n        db.add(new_user)\n        db.commit()\n        db.refresh(new_user)\n        \n        return new_user\n    \n    async def authenticate_user(\n        self,\n        credentials: UserLogin,\n        db: Session\n    ) -> User:\n        \"\"\"\n        Authenticate a user with email and password\n        \"\"\"\n        user = db.query(User).filter(User.email == credentials.email).first()\n        \n        if not user:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid email or password\"\n            )\n        \n        if not user.is_active:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Account is disabled\"\n            )\n        \n        if not self.verify_password(credentials.password, user.hashed_password):\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid email or password\"\n            )\n        \n        # Update last login\n        user.last_login = datetime.utcnow()\n        db.commit()\n        \n        return user\n    \n    async def create_user_session(\n        self,\n        user: User,\n        ip_address: Optional[str] = None,\n        user_agent: Optional[str] = None,\n        db: Session = None\n    ) -> Token:\n        \"\"\"\n        Create a new user session and return JWT token\n        \"\"\"\n        # Create access token\n        access_token_expires = timedelta(minutes=self.access_token_expire_minutes)\n        access_token = self.create_access_token(\n            data={\"sub\": str(user.id), \"username\": user.username},\n            expires_delta=access_token_expires\n        )\n        \n        # Create session record\n        session = UserSession(\n            user_id=user.id,\n            session_token=access_token,\n            ip_address=ip_address,\n            user_agent=user_agent,\n            expires_at=datetime.utcnow() + access_token_expires\n        )\n        \n        if db:\n            db.add(session)\n            db.commit()\n        \n        return Token(\n            access_token=access_token,\n            token_type=\"bearer\",\n            expires_in=self.access_token_expire_minutes * 60\n        )\n    \n    async def get_current_user(\n        self,\n        token: str,\n        db: Session\n    ) -> User:\n        \"\"\"\n        Get the current user from JWT token\n        \"\"\"\n        credentials_exception = HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Could not validate credentials\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n        \n        payload = self.verify_token(token)\n        if payload is None:\n            raise credentials_exception\n        \n        user_id: str = payload.get(\"sub\")\n        if user_id is None:\n            raise credentials_exception\n        \n        # Check if session is still valid\n        session = db.query(UserSession).filter(\n            UserSession.session_token == token,\n            UserSession.is_active == True,\n            UserSession.expires_at > datetime.utcnow()\n        ).first()\n        \n        if not session:\n            raise credentials_exception\n        \n        # Get user\n        user = db.query(User).filter(User.id == user_id).first()\n        if user is None:\n            raise credentials_exception\n        \n        if not user.is_active:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Account is disabled\"\n            )\n        \n        return user\n    \n    async def logout_user(\n        self,\n        token: str,\n        db: Session\n    ) -> Dict[str, str]:\n        \"\"\"\n        Logout user by invalidating the session\n        \"\"\"\n        session = db.query(UserSession).filter(\n            UserSession.session_token == token,\n            UserSession.is_active == True\n        ).first()\n        \n        if session:\n            session.is_active = False\n            db.commit()\n        \n        return {\"message\": \"Successfully logged out\"}\n    \n    async def refresh_token(\n        self,\n        current_token: str,\n        db: Session\n    ) -> Token:\n        \"\"\"\n        Refresh an access token\n        \"\"\"\n        # Verify current token\n        payload = self.verify_token(current_token)\n        if payload is None:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid token\"\n            )\n        \n        user_id = payload.get(\"sub\")\n        user = db.query(User).filter(User.id == user_id).first()\n        \n        if not user or not user.is_active:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"User not found or inactive\"\n            )\n        \n        # Invalidate old session\n        await self.logout_user(current_token, db)\n        \n        # Create new session\n        return await self.create_user_session(user, db=db)\n    \n    async def cleanup_expired_sessions(self, db: Session):\n        \"\"\"\n        Clean up expired user sessions\n        \"\"\"\n        expired_sessions = db.query(UserSession).filter(\n            UserSession.expires_at < datetime.utcnow()\n        ).all()\n        \n        for session in expired_sessions:\n            session.is_active = False\n        \n        db.commit()\n        \n        return len(expired_sessions)\n    \n    async def get_user_sessions(\n        self,\n        user_id: str,\n        db: Session,\n        include_inactive: bool = False\n    ) -> list[UserSession]:\n        \"\"\"\n        Get all sessions for a user\n        \"\"\"\n        query = db.query(UserSession).filter(UserSession.user_id == user_id)\n        \n        if not include_inactive:\n            query = query.filter(\n                UserSession.is_active == True,\n                UserSession.expires_at > datetime.utcnow()\n            )\n        \n        return query.order_by(UserSession.created_at.desc()).all()\n    \n    async def revoke_all_sessions(\n        self,\n        user_id: str,\n        except_token: Optional[str] = None,\n        db: Session = None\n    ):\n        \"\"\"\n        Revoke all sessions for a user (except the current one if specified)\n        \"\"\"\n        query = db.query(UserSession).filter(\n            UserSession.user_id == user_id,\n            UserSession.is_active == True\n        )\n        \n        if except_token:\n            query = query.filter(UserSession.session_token != except_token)\n        \n        sessions = query.all()\n        \n        for session in sessions:\n            session.is_active = False\n        \n        db.commit()\n        \n        return len(sessions)"