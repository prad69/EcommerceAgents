from datetime import datetime\nfrom typing import Optional, List, Dict, Any\nfrom pydantic import BaseModel, Field\n\n\n# Chatbot Schemas\nclass ChatMessage(BaseModel):\n    role: str  # user, assistant, system\n    content: str\n    timestamp: datetime\n    metadata: Optional[Dict[str, Any]] = None\n\n\nclass ChatbotRequest(BaseModel):\n    message: str = Field(..., min_length=1, max_length=1000)\n    user_id: Optional[str] = None\n    session_id: str\n    context: Optional[Dict[str, Any]] = Field(default_factory=dict)\n    conversation_history: Optional[List[ChatMessage]] = Field(default_factory=list)\n\n\nclass ChatbotResponse(BaseModel):\n    message: str\n    session_id: str\n    response_type: str  # text, product_recommendation, escalation\n    confidence: float\n    suggested_products: Optional[List[str]] = None  # Product IDs\n    metadata: Optional[Dict[str, Any]] = None\n    response_time: float\n\n\n# Review Analysis Schemas\nclass ReviewAnalysisRequest(BaseModel):\n    product_id: Optional[str] = None\n    review_text: Optional[str] = None\n    reviews: Optional[List[str]] = None  # Multiple review texts\n    analysis_type: str = Field(\"full\")  # full, sentiment, themes, summary\n\n\nclass SentimentAnalysis(BaseModel):\n    sentiment: str  # positive, neutral, negative\n    confidence: float\n    score: float  # -1 to 1\n\n\nclass ThemeExtraction(BaseModel):\n    theme: str\n    mentions: int\n    sentiment: str\n    examples: List[str]\n\n\nclass ReviewAnalysisResponse(BaseModel):\n    product_id: Optional[str]\n    total_reviews: int\n    overall_sentiment: SentimentAnalysis\n    sentiment_breakdown: Dict[str, int]\n    key_themes: List[ThemeExtraction]\n    pros: List[str]\n    cons: List[str]\n    summary: str\n    processing_time: float\n\n\n# Content Generation Schemas\nclass ContentGenerationRequest(BaseModel):\n    product_id: Optional[str] = None\n    product_data: Optional[Dict[str, Any]] = None\n    content_type: str = Field(\"description\")  # description, title, features, seo\n    template: str = Field(\"basic\")  # basic, seo, detailed, creative\n    target_audience: Optional[str] = None\n    tone: str = Field(\"professional\")  # professional, casual, enthusiastic\n    length: str = Field(\"medium\")  # short, medium, long\n    include_keywords: Optional[List[str]] = None\n\n\nclass ContentGenerationResponse(BaseModel):\n    content: str\n    content_type: str\n    template_used: str\n    seo_score: Optional[float] = None\n    readability_score: Optional[float] = None\n    keyword_density: Optional[Dict[str, float]] = None\n    generation_time: float\n    metadata: Optional[Dict[str, Any]] = None\n\n\n# General Agent Schemas\nclass AgentStatus(BaseModel):\n    agent_type: str\n    status: str  # healthy, degraded, unhealthy\n    last_check: datetime\n    version: str\n    uptime: float\n    response_time: float\n    error_rate: float\n\n\nclass AgentTask(BaseModel):\n    task_id: str\n    agent_type: str\n    task_type: str\n    input_data: Dict[str, Any]\n    status: str  # pending, processing, completed, failed\n    created_at: datetime\n    completed_at: Optional[datetime] = None\n    result: Optional[Dict[str, Any]] = None\n    error_message: Optional[str] = None\n\n\nclass BatchProcessingRequest(BaseModel):\n    agent_type: str\n    tasks: List[Dict[str, Any]]\n    priority: str = Field(\"normal\")  # low, normal, high\n    callback_url: Optional[str] = None\n\n\nclass BatchProcessingResponse(BaseModel):\n    batch_id: str\n    total_tasks: int\n    estimated_completion: datetime\n    status_url: str"